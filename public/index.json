
[{"content":"","date":"September 22, 2025","externalUrl":null,"permalink":"/posts/","section":"Blog","summary":"","title":"Blog","type":"posts"},{"content":"Hello! I am a PhD in Economics at Emory University, I will join Beihang University in Fall 2025. My research interests are macroeconomics, international finance, and computational economics.\n➡️ Curriculum Vitae ➡️ Email: tianhao.zhao@emory.edu (expires in mid-Sep 2025) ➡️ Email: tianhao.zhao@alumni.emory.edu ","date":"September 22, 2025","externalUrl":null,"permalink":"/","section":"homepage","summary":"","title":"homepage","type":"page"},{"content":" Introduction # Deriving the full non-linear Phillips curve in a New Keynesian model can take a lot of time, and it’s easy to make mistakes along the way. This post walks through the process step by step, with every stage written out clearly so that even graduate students just starting out in this literature can follow. The example here uses a heterogeneous-producer setup with Rotemberg-style price rigidity.\nConsider a two-stage production structure with a continuum of differentiated intermediate producers and a final goods producer. All producers solve their profit maximization problem. Each intermediate producer of type \\(i \\in [0,1]\\) produces an intermediate good \\(y_t(i)\\) using the technology \\(f(k(i),\\ell(i))\\), where \\(k(i)\\) is capital rented at the nominal interest rate \\(R_t\\) and \\(\\ell(i)\\) is labor hired at the nominal wage rate \\(W_t\\). The final goods producer aggregates all intermediate goods into the final output \\(y_t\\) using the CES aggregator:\n$$ y_t = \\left( \\int_0^1 y_t(i)^{\\frac{\\varepsilon-1}{\\varepsilon}} \\, \\text{d} i \\right)^{\\frac{\\varepsilon}{\\varepsilon-1}} $$where \\(\\varepsilon\\) denotes the elasticity of substitution across intermediate goods. In each period \\(t\\), individual intermediate producers choose how much capital \\(k(i)\\) and labor \\(\\ell(i)\\) to hire, and set their own nominal prices \\(P_t(i)\\), while taking the nominal wage rate \\(W_t\\) and nominal interest rate \\(R_t\\) as given. The aggregate price level (or index) is defined as:\n$$ P_t^{1-\\varepsilon} = \\int_0^1 P_t(i)^{1-\\varepsilon} \\text{d} i $$At the same time, each intermediate producer faces a Rotemberg-type cost of adjusting nominal prices (nominal price rigidity):\n$$ \\text{AdjC}_t(i) := \\varphi(i) \\cdot P_t(i) y_t(i) := \\frac{\\theta}{2}\\left( \\pi_t(i) - \\bar{\\pi} \\right)^2 \\cdot P_t(i) \\, y_t(i) $$where \\(\\pi_t(i) = \\frac{P_t(i)}{P_{t-1}(i)}\\) is the gross inflation rate and \\(\\bar{\\pi}\\) is the inflation target (e.g., \\(1.02\\) for the U.S. economy). Intuitively, the adjustment cost is quadratic in the nominal value of output for producer \\(i\\).\nWhen we say \u0026ldquo;solving the production part,\u0026rdquo; we are in fact solving the profit maximization problem of both the intermediate producers and the final goods producer. The (non-linear) Phillips curve emerges as the equilibrium Euler equation of type-\\(i\\) intermediate producers. In the symmetric equilibrium, where \\(P_t(i) = P_t\\) for all \\(i \\in [0,1]\\), the same Phillips curve applies to all producers. However, the non-linear Phillips curve is often highly complex, so it is common to approximate it by taking a Taylor expansion around the deterministic steady state. When the expansion is truncated at first order, the result is the familiar linear Phillips curve widely used in quantitative studies.\nIn the following sections, we will go through this procedure:\nSolving the final producer\u0026rsquo;s profit maximization by choosing a set of intermediate goods \\(\\{P_t(i):i \\in [0,1]\\}\\). Solving this problem gives the (final producer\u0026rsquo;s) demand for intermediate goods Solving the intermediate producer of type-\\(i\\)\u0026rsquo;s profit maximization Solving the cost minimization problem by choosing \\((k(i),\\ell(i))\\) while taking the price \\(P_i(t)\\) and demand \\(y_t(i)\\) as given Plugging in the allocation, and solving the profit maximization by choosing price \\(P_i(t)\\) or equivalently the inflation rate \\(\\pi_t\\), whlie taking the demand \\(y_t(i)\\) as given Deriving the non-linear Phillips curve (Optional) expanding the Phillips curve Computing the aggregate variables (e.g. aggregate output, aggregate capital/labor demand) by specifying the function form of the technology \\(f(k,\\ell)\\) Final producer\u0026rsquo;s profit maximization # The final producer takes all prices as given and solve the following problem by choosing a set of intermediate goods \\(\\{y_t(i):i \\in[0,1]\\}\\):\n$$ \\begin{aligned} \\max_{\\{ y_t(i):i\\in[0,1] \\}} \u0026 P_t y_t - \\int_0^1 P_t(i) \\cdot y_t(i) \\text{d} i \\\\ \u0026 y_t = \\left( \\int_0^1 y_t(i)^\\frac{\\varepsilon-1}{\\varepsilon} \\text{d} i \\right)^\\frac{\\varepsilon}{\\varepsilon-1} \\end{aligned} $$The idea of solving this problem is standard: take the first order condition (FOC) and solve for the optimal \\(y_t(i)\\) and denote it with aggregate variables \\(y_t\\). But, one must pay attention that there are inifinite number of FOC as \\(i\\) is continuous in range \\([0,1]\\). Step-by-step, taking FOC for type-\\(i\\) goods:\n$$ \\begin{aligned} \u0026 P_t \\cdot \\left[ \\int_0^1 y_t(i)^\\frac{\\varepsilon-1}{\\varepsilon} \\text{d} i \\right]^\\frac{1}{\\varepsilon-1} \\cdot y_t(i)^{-\\frac{1}{\\varepsilon}} = P_t(i) \\\\ \\implies\u0026 P_t \\cdot y_t^\\frac{1}{\\varepsilon} \\cdot y_t(i)^{-\\frac{1}{\\varepsilon}} = P_t(i) \\\\ \\implies\u0026 y_t(i) = \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon}\\cdot y_t \\end{aligned} $$In this way, we can uniformly denote the demand of every single type of intermediate producer as a fraction of the aggregate output. The fraction form gives extra convenience when we do aggregation later.\nIntermediate producer\u0026rsquo;s profit maximization # The intermediate producer of type \\(i\\) solves the following dynamic programming problem while taking all prices, including their own price \\(P_{t-1}(i)\\) from the last period:\n$$ \\begin{aligned} \u0026 \\omega_i(P_{t-1}(i);\\mathcal{S}_t) := \\max_{P_t(i),k_t(i),\\ell_t(i)} \\Pi_t(i) + \\beta \\mathbb{E}\\left\\{ \\omega_i(P_{t}(i);\\mathcal{S}_{t+1}) | \\mathcal{S}_{t} \\right\\} \\\\ \u0026 \\Pi_t(i) := P_t(i) \\cdot y_t(i) - \\text{AdjC}_t(i) - \\left\\{ W_t \\ell_t(i) + R_t k_t(i) \\right\\} \\\\ \u0026 \\text{AdjC}_t(i) := \\varphi(i) \\cdot P_t(i) y_t(i) := \\frac{\\theta}{2}\\left( \\pi_t(i) - \\bar{\\pi} \\right)^2 \\cdot P_t(i) \\, y_t(i) \\\\ \u0026 \\pi_t(i) := P_t(i) / P_{t-1}(i) \\end{aligned} $$where \\(\\Pi_t(i)\\) is the flow profit of the producer, \\(\\text{AdjC}_t(i)\\) is the adjustment cost of Rotemberg type, and \\(\\mathcal{S}_t\\) is the information set for decision making. Solving the problem is a multivariable optimization in which, in general, all three controls must be considered simultaneously. However, notice that the costs of the input factors enter the objective function in a linear and separable way. This allows us to first isolate the cost-minimization problem of choosing \\((k_t(i), \\ell_t(i))\\), and then substitute the solution back into the objective function to simplify the remaining price-adjustment choice by leaving only one control \\(P_t(i)\\).\nComment: here we assume the inflation target \\(\\overline\\pi\\) is the same across all types of producers which gives us some nice aggregation results. In quantitative models, this target can be different and the algebra follows this post\u0026rsquo;s spirit.\nCost minimization step # The intermediate producer of type \\(i\\) solves the following cost minimization problem:\n$$ \\begin{aligned} \u0026 \\min_{k_t(i),\\ell_t(i)} W_t \\ell_t(i) + R_t k_t(i) \\\\ \u0026 \\text{s.t. } y_t (i) = f(k_t(i),\\ell_t(i)) \\end{aligned} $$To move on, let\u0026rsquo;s assume a function form of \\(f(\\cdot)\\):\n$$ \\begin{aligned} f(k,\\ell|Z) := Z_t k^{\\alpha_1} \\ell^{\\alpha_2} \\end{aligned} $$where \\(Z_t\\) is the (separable) productivity, and \\(\\alpha_1 + \\alpha_2\\) may or may not equal to 1 (even though we will work with the case \\(\\alpha_1+\\alpha_2=1\\) almost through this post). The product structure allows us to simplify the algebra greatly to get a clean analytical solution, while the relaxed assumption on the scale to returns alows us to explore the impact of price dispersion across the intermediate producers later.\nTo solve the problem, let\u0026rsquo;s define the Lagrangian for type-\\(i\\) producer:\n$$ L(i) := W_t \\ell_t(i) + R_t k_t(i) + M_t(i) \\cdot ( y_t(i) - Z_t(i) k_t(i)^{\\alpha_1} \\ell_t(i)^{\\alpha_2} ) $$where \\(M_t(i)\\) is the marginal cost (MC), i.e. the real unit cost of producing more output \\(y_t(i)\\). The FOC is then:\n$$ \\begin{aligned} R_t =\u0026 M_t(i) \\cdot Z_t(i) \\cdot \\alpha_1 k_t(i)^{\\alpha_1-1} \\ell_t(i)^{\\alpha_2} \\\\ =\u0026 M_t(i) \\cdot \\alpha_1 \\cdot y_t(i) / k_t(i) \\\\ W_t =\u0026 M_t(i) \\cdot Z_t(i) \\cdot \\alpha_2 k_t(i)^{\\alpha_1} \\ell_t(i)^{\\alpha_2-1} \\\\ =\u0026 M_t(i) \\cdot \\alpha_2 \\cdot y_t(i) / \\ell_t(i) \\\\ \\end{aligned} $$From standard textbooks we know that the first-order conditions (FOC) of the above problem do not yield a unique optimal point \\((k_t(i), \\ell_t(i))\\) to substitute directly. Instead, they characterize a straight line along which the ratio of the optimal inputs is proportional to the relative price \\(R_t/W_t\\). This raises the question: how can we proceed? An intuitive approach is to construct the average cost (AC) of producing one unit of output \\(y_t(i)\\) without explicitly involving either \\(k_t(i)\\) or \\(\\ell_t(i)\\). Since our goal is to eliminate the input allocation from the profit maximization by separating the process into two stages, this allows us to write the profit as\n$$ \\left( P_t(i) - \\text{AC}_t(i) \\right) \\cdot y_t(i). $$Intuitively, expressing AC independently of \\((k_t(i), \\ell_t(i))\\) requires specific assumptions about returns to scale. A common and standard choice is a Cobb–Douglas technology with constant returns to scale, which in this case implies \\(\\alpha_1 + \\alpha_2 = 1\\). The Cobb–Douglas form also provides a useful property: the average cost is equal to the marginal cost. To explore this idea, we apply the following algebraic trick. First, denote \\(M_t(i)\\) using the two first-order conditions:\n$$ \\begin{aligned} \u0026 M_t(i) = \\frac{R_t\\cdot k_t(i) }{\\alpha_1 y_t(i)} = \\frac{W_t\\cdot \\ell_t(i) }{\\alpha_2 y_t(i)} \\end{aligned} $$Then, the key step is to further combine the two equations by raising \\(M_t(i)\\) to its Cobb-Douglas share respectively:\n$$ \\begin{aligned} M_t(i) =\u0026 M_t(i)^{\\alpha_1} \\cdot M_t(i)^{\\alpha_2} = \\left[ \\frac{R_t\\cdot k_t(i) }{\\alpha_1 y_t(i)} \\right]^{\\alpha_1} \\cdot \\left[ \\frac{W_t\\cdot \\ell_t(i) }{\\alpha_2 y_t(i)} \\right]^{\\alpha_2} \\\\ =\u0026 \\left[ \\frac{R_t\\cdot }{\\alpha_1} \\right]^{\\alpha_1} \\cdot \\left[ \\frac{W_t\\cdot }{\\alpha_2} \\right]^{\\alpha_2} \\cdot \\frac{k_t(i)^{\\alpha_1} \\ell_t(i)^{\\alpha_2} }{y_t(i)^{\\alpha_1 + \\alpha_2}} \\\\ =\u0026 \\frac{1}{Z_t(i)} \\cdot \\left[ \\frac{R_t }{\\alpha_1} \\right]^{\\alpha_1} \\cdot \\left[ \\frac{W_t }{\\alpha_2} \\right]^{\\alpha_2} \\end{aligned} $$in which the marginal cost is only about the factor prices, income share, and inverse to the technology level.\nHint: showing AC = MC with Cobb-Douglas technology\nRepresent the optimal allocation with FOC, then: $$ \\begin{aligned} \\text{AC}_t(i) =\u0026 (W_t \\ell_t(i) + R_t k_t(i))/y_t(i) \\\\ =\u0026 \\frac{1}{y_t(i)}\\left[ W_t \\cdot \\frac{M_t(i)}{W_t} \\alpha_2 y_t(i) + R_t \\cdot \\frac{M_t(i)}{R_t} \\alpha_1 y_t(i) \\right] \\\\ =\u0026 \\frac{M_t(i) y_t(i)}{y_t(i)} = M_t(i) \\end{aligned} $$ Hint: In many applications, \\(Z_t(i)\\) is the same across all the intermediate producers, and/or is normalized to 1. This simplifies the algebra further.\nHint: Plugging the optimality condition and the demand of type-\\(i\\) intermediate goods back to the budget constraint of the cost minimization problem, $$ k_t(i) = \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} k_t, \\ell_t(i) = \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} \\ell_t $$ So far, the cost minimization problem has been solved: the cost of production is \\(M_t(i) y_t(i)\\) and \\(M_t(i)\\) is represented without the allocation of \\((k_t(i),\\ell_t(i))\\).\nProfit maximization step # Plugging the minimized cost function, the solved demand for type-\\(i\\) intermediate goods, and plugging in the price adjustment cost into the type-\\(i\\) producer\u0026rsquo;s profit maximization problem, there is:\n$$ \\begin{aligned} \u0026 \\omega_i(P_{t-1}(i);\\mathcal{S}_t) := \\max_{P_t(i)} \\Pi_t(i) + \\beta \\mathbb{E}\\left\\{ \\omega_i(P_{t}(i);\\mathcal{S}_{t+1}) | \\mathcal{S}_{t} \\right\\} \\\\ \u0026 \\Pi_t(i) := [ (1 - \\varphi_t(i))P_t(i) - M_t(i) ] \\cdot \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon}\\cdot y_t \\\\ \u0026 \\varphi_t(i) := \\frac{\\theta}{2} (\\pi_t(i) - \\bar{\\pi})^2 \\\\ \u0026 \\pi_t(i) := P_t(i) / P_{t-1}(i) \\end{aligned} $$The only control variable left is \\(P_t(i)\\), or equivalently the inflation \\(\\pi_t(i)\\).The type-\\(i\\) producer takes \\((P_{t-1}(i),P_t,M_t(i),y_t)\\) as given. To solve this problem, let\u0026rsquo;s derive the FOC by taking the derivatives of the Lagrangian \\(L_t(i)\\) wrt \\(P_t(i)\\)\n$$ \\begin{aligned} \u0026 \\frac{\\partial L_t(i)}{\\partial P_t(i)} = \\frac{\\partial \\Pi_t(i)}{\\partial P_t(i)} + \\beta \\mathbb{E}\\left\\{ \\frac{\\partial}{\\partial P_t(i)} \\omega_i(P_{t}(i);\\mathcal{S}_{t+1}) \\right\\} = 0 \\end{aligned} $$Let\u0026rsquo;s derive the two terms separately.\nDerivatives of flow profit # $$ \\begin{aligned} \u0026 \\frac{\\partial \\Pi_t(i)}{\\partial P_t(i)} = y_t \\cdot \\Big\\{ [(1-\\varphi_t(i))P_t(i) - M_t(i)] \\cdot \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} \\cdot (-\\varepsilon) P_t(i)^{-1} \\\\ \u0026 + \\left[ 1 - \\varphi_t(i) - \\frac{\\partial \\varphi_t(i)}{\\partial P_t(i)} P_t(i) \\right] \\cdot \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} \\Big\\} \\\\ % --------------- \u0026 = \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} \\cdot y_t \\cdot \\Big\\{ -\\varepsilon\\cdot(1-\\varphi_t(i)) + \\varepsilon\\cdot M_t(i)\\cdot P_t(i)^{-1} \\\\ \u0026 + 1 - \\varphi_t(i) - \\frac{\\partial \\varphi_t(i)}{\\partial P_t(i)} P_t(i) \\Big\\} \\\\ % --------------- \u0026 = \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} \\cdot y_t \\cdot \\Big\\{ (1 - \\varepsilon)(1 - \\varphi_t(i)) + \\varepsilon \\cdot M_t(i) \\cdot P_t(i)^{-1} - \\frac{\\partial \\varphi_t(i)}{\\partial P_t(i)} P_t(i) \\Big\\} \\\\ \\end{aligned} $$Knowing that:\n$$ \\begin{aligned} \\frac{\\partial \\varphi_t(i)}{\\partial P_t(i)} P_t(i) =\u0026 \\theta \\left[ \\frac{P_t(i)}{P_{t-1}(i)} - \\bar{\\pi} \\right] \\cdot \\frac{1}{P_{t-1}(i)} \\cdot P_t(i) = \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\end{aligned} $$The re-arranged equation is:\n$$ \\begin{aligned} \u0026 \\frac{\\partial \\Pi_t(i)}{\\partial P_t(i)} = \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} y_t \\cdot \\\\\u0026\\Big\\{ (1 - \\varepsilon)(1 - \\varphi_t(i)) + \\varepsilon \\cdot \\frac{M_t(i)}{P_t(i)} - \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\Big\\} \\end{aligned} $$ Derivatives of the expected value # $$ \\Pi_t(i) := [ (1 - \\varphi_t(i))P_t(i) - M_t(i) ] \\cdot \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon}\\cdot y_t $$Applying envelope theorem to the value function, there is:\n$$ \\begin{aligned} \u0026 \\frac{\\partial}{\\partial P_{t-1}(i)} \\omega_i(P_{t-1}(i);\\mathcal{S}_{t}) = \\frac{\\partial}{\\partial P_{t-1}(i)} \\Pi_t(i) \\\\ =\u0026 \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon}\\cdot y_t \\cdot P_t(i) \\cdot (-1) \\cdot \\frac{\\partial \\varphi_t(i)}{\\partial P_{t-1}(i)} \\end{aligned} $$Knowing that:\n$$ \\begin{aligned} \u0026 \\frac{\\partial \\varphi_t(i)}{\\partial P_{t-1}(i)} = -\\theta (\\pi_t(i) - \\bar{\\pi}) \\cdot \\frac{\\pi_t(i)}{P_{t-1}(i)} \\end{aligned} $$Re-arrange the derivatives and get:\n$$ \\begin{aligned} \u0026 \\frac{\\partial}{\\partial P_{t-1}(i)} \\omega_i(P_{t-1}(i);\\mathcal{S}_{t}) = \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon}\\cdot y_t \\cdot P_t(i) \\cdot \\theta (\\pi_t(i) - \\bar{\\pi}) \\cdot \\frac{\\pi_t(i)}{P_{t-1}(i)} \\\\ \u0026= \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon}\\cdot y_t \\cdot \\theta (\\pi_t(i) - \\bar{\\pi}) \\cdot \\pi_t(i)^2 \\end{aligned} $$Moving forward for one period and get:\n$$ \\frac{\\partial}{\\partial P_{t}(i)} \\omega_i(P_{t}(i);\\mathcal{S}_{t+1}) = \\left( \\frac{P_{t+1}(i)}{P_{t+1}} \\right)^{-\\varepsilon}\\cdot y_{t+1} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 $$ Non-linear Phillips curve # The non-linear Phillips curve is obtianed by re-arranging the FOC of type-\\(i\\) producer after plugging the above terms back. The equations may be very long and readers may have to move the slider.\n$$ \\begin{aligned} \u0026 \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} y_t \\cdot \\Big\\{ (1 - \\varepsilon)(1 - \\varphi_t(i)) + \\varepsilon \\cdot \\frac{M_t(i)}{P_t(i)} - \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\Big\\} \\\\ \u0026+ \\beta \\mathbb{E} \\left\\{ \\left( \\frac{P_{t+1}(i)}{P_{t+1}} \\right)^{-\\varepsilon}\\cdot y_{t+1} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 \\right\\} = 0 \\end{aligned} $$Move the flow profit derivatives to another side of the equation while flipping the term signs:\n$$ \\begin{aligned} \u0026 \\left( \\frac{P_t(i)}{P_t} \\right)^{-\\varepsilon} y_t \\cdot \\Big\\{ \\color{red}(\\varepsilon - 1)\\color{black}(1 - \\varphi_t(i)) \\color{red}-\\color{black} \\varepsilon \\cdot \\frac{M_t(i)}{P_t(i)} \\color{red}+\\color{black} \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\Big\\} \\\\ \u0026= \\beta \\mathbb{E} \\left\\{ \\left( \\frac{P_{t+1}(i)}{P_{t+1}} \\right)^{-\\varepsilon}\\cdot y_{t+1} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 \\right\\} \\end{aligned} $$Then, move the demand term to the RHS and convert some price changes to inflation for convenience:\n$$ \\begin{aligned} \u0026(\\varepsilon - 1)(1 - \\varphi_t(i)) - \\varepsilon \\cdot \\frac{M_t(i)}{P_t(i)} + \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\\\ \u0026= \\beta \\mathbb{E}\\left\\{ \\left( \\frac{P_{t+1}(i)/P_t(i)}{P_{t+1}/P_t} \\right)^{-\\varepsilon}\\cdot \\frac{y_{t+1}}{y_t} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 \\right\\} \\end{aligned} $$Define aggregate inflation \\(\\pi_t := P_t / P_{t-1}\\). Re-arrange some terms (terms in red color need special attention in each step):\n$$ \\begin{aligned} \u0026\\color{red} \\varepsilon-1 -\\frac{\\theta(\\varepsilon-1)}{2}(\\pi_t(i) - \\bar{\\pi})^2 \\color{black} - \\varepsilon \\cdot \\frac{M_t(i)}{P_t(i)} + \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\\\ \u0026= \\beta \\mathbb{E}\\left\\{ \\color{red} \\left(\\frac{\\pi_{t+1}(i)}{\\pi_{t+1}}\\right)^{-\\varepsilon} \\color{black} \\cdot \\frac{y_{t+1}}{y_t} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 \\right\\} \\\\ % ----------- \\implies\u0026\\color{red} \\varepsilon \\left[ 1 - \\frac{M_t(i)}{P_t(i)} \\right] \\color{black} - 1 - \\frac{\\theta(\\varepsilon-1)}{2}(\\pi_t(i) - \\bar{\\pi})^2 + \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\\\ \u0026= \\beta \\mathbb{E}\\left\\{ \\left(\\frac{\\pi_{t+1}(i)}{\\pi_{t+1}}\\right)^{-\\varepsilon} \\cdot \\frac{y_{t+1}}{y_t} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 \\right\\} \\end{aligned} $$Finally, extracting the price deviation \\(\\frac{P_t}{P_t(i)}\\) out of the first term on the LHS, we get the (non-linear) Phillips curve that charaterizes how type-\\(i\\) producer\u0026rsquo;s optimal inflation evolves across time. It is easy to realize that the Phillips curve is nothing else but the Euler equation of type-\\(i\\) producer\u0026rsquo;s profit maximization problem.\n$$ \\begin{aligned} \u0026 \\varepsilon\\frac{P_t}{P_t(i)} \\left[ \\frac{P_t(i)}{P_t} - \\frac{M_t(i)}{P_t} \\right] - 1 - \\frac{\\theta(\\varepsilon-1)}{2}(\\pi_t(i) - \\bar{\\pi})^2 + \\theta ( \\pi_t(i) - \\bar{\\pi} ) \\cdot \\pi_t(i) \\\\ \u0026= \\beta \\mathbb{E}\\left\\{ \\left(\\frac{\\pi_{t+1}(i)}{\\pi_{t+1}}\\right)^{-\\varepsilon} \\cdot \\frac{y_{t+1}}{y_t} \\cdot \\theta (\\pi_{t+1}(i) - \\bar{\\pi}) \\cdot \\pi_{t+1}(i)^2 \\right\\} \\end{aligned} $$where:\n\\(P_t(i) - M_t(i)\\) is the unit nominal profit; \\(\\frac{P_t(i) - M_t(i)}{P_t(i)}\\) is the nominal profit rate; \\(P_t(i)/P_t\\) is the real price of type-\\(i\\) producer\u0026rsquo;s intermediate goods; and \\(M_t(i)/P_t\\) is the real marginal cost \\(\\pi_t(i)/\\pi_t\\) is the inflation dispersion \\(y_{t+1}/y_{t}\\) is the real growth Remark: Even though we have been sticking to the notation of marginal cost \\(M_t(i)\\), one must realize that it is average cost that should be considered. The nice substitution here is due to the property of constant returns to scale (CRS) of the Cobb-Douglas technology, which isolates the inflation policy making from choosing the allocation. In a general setup, it might be essential to jointly solve the optimal inflaiton and allocation.\nIn stationary equilibrium (no-trend or detrended, basically \\(\\overline\\pi=1\\)), type-$i$ producer\u0026rsquo;s price level \\(P_t(i) \\equiv \\bar{P}(i)\\) such that \\(\\pi_t(i)\\equiv \\bar\\pi(i)\\); the marginal cost \\(M_t(i) \\equiv \\bar{M}(i)\\). Meanwhile, all the aggregate quantities are the same. Plugging the conditions to the Phillips curve and eliminate almost all terms:\n$$ \\begin{aligned} \u0026 \\varepsilon \\frac{\\bar{P}}{\\bar{P}(i)} \\left( \\frac{\\bar{P}(i)}{\\bar{P}} - \\frac{\\bar{M}(i)}{\\bar{P}} \\right) - 1 = 0 \\\\ % ------ \\implies\u0026 \\underbrace{ \\bar{p}(i) - \\bar{m}(i) }_{\\text{real premium (unit profit)}} = \\frac{\\bar{p}(i)}{\\varepsilon} \\\\ % ------ \\implies\u0026 \\bar{m}(i) = \\frac{\\varepsilon-1}{\\varepsilon} \\overline{p}(i) \\end{aligned} $$where the notations in lower case mean the values in real term (deflated by the aggregate price level \\(P_t\\)).\nLinearized Phillips curve # The non-linear Phillips curve captures the exact dynamics of a type-\\(i\\) producer\u0026rsquo;s optimal pricing and inflation decisions, but the resulting equation is often complex and difficult to interpret. For empirical applications, economists typically rely on its linear approximation around the stationary equilibrium, which yields a much more transparent and tractable form.\nIt is known that log linearization is equivalent to 1st order Taylor expansion, such that we\u0026rsquo;ll do log linearization for convenience. Define log-deviation \\(\\hat{x}:= \\log{x} - \\log\\overline{x}\\) for a positive-valued variable \\(x\\) where $\\overline{x}$ is the point where to do the approximation/expansion. Around the point to expand, there are approximations:\n$$ \\begin{aligned} \u0026 x \\approx \\overline{x}(1+\\hat{x}) \\\\ \u0026 x^\\alpha \\approx \\overline{x}(1 + \\alpha \\hat{x}) \\\\ \u0026 \\frac{x}{y} \\approx \\frac{\\overline{x}}{\\overline{y}}(1 + \\hat{x} - \\hat{y}) \\\\ \u0026 \\hat{x}\\cdot \\hat{y} \\approx 0 \\end{aligned} $$ Hint: Some common terms in the Phillips curve has: $$ \\begin{aligned} \u0026 \\pi_t(i) - \\overline\\pi \\approx \\overline\\pi(1+\\hat\\pi_t(i)) - \\overline\\pi = \\overline\\pi \\cdot \\hat\\pi_t(i) \\\\ \u0026 (\\pi_t(i) - \\overline\\pi)^2 \\approx \\overline\\pi^2 \\cdot \\hat\\pi_t(i)^2 \\approx 0 \\\\ \u0026 \\frac{\\pi_t(i)}{\\pi_t} \\approx 1+\\hat\\pi_t(i) -\\hat\\pi_t \\\\ \u0026 \\frac{y_{t+1}}{y_t} \\approx 1 + \\hat{y}_{t+1} - \\hat{y}_t \\end{aligned} $$ Hint: The whole RHS of the Phillips curve is approximately zero due to the higher-order terms of \\(\\pi_{t+1}(i)\\).\nThe algebra is then left for exercises.\nAggregations # After solving individual producer\u0026rsquo;s problem, it is time to aggregate them up to obtain the aggregate policies. In this section, we will see how the price dispersion \\(\\delta_t\\) matters in determining the aggregate output, inflation, and premium.\n$$ \\delta_t := \\int_0^1 \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} \\text{d} i $$ Output # The aggregate output of the final goods \\(y_t\\) can be solved by plugging the demand for intermediate goods of type \\(i\\) back to the CES aggregation:\n$$ \\begin{aligned} y_t =\u0026 \\left( \\int_0^1 y_t(i)^\\frac{\\varepsilon-1}{\\varepsilon} \\text{d} i \\right)^\\frac{\\varepsilon}{\\varepsilon-1} \\\\ % -------- y_t^{\\frac{\\varepsilon-1}{\\varepsilon}} =\u0026 \\int_0^1 y_t(i)^\\frac{\\varepsilon-1}{\\varepsilon} \\text{d} i \\\\ =\u0026 \\int_0^1 [ Z_t(i) k_t(i)^{\\alpha_1} \\ell_t(i)^{\\alpha_2} ]^{\\frac{\\varepsilon-1}{\\varepsilon}} \\text{d} i \\end{aligned} $$For simplicity, let\u0026rsquo;s consider a special case where \\(Z_t(i) \\equiv Z_t\\) which is standard in many applications.\n$$ \\begin{aligned} y_t^{\\frac{\\varepsilon-1}{\\varepsilon}} =\u0026 Z_t^{\\frac{\\varepsilon-1}{\\varepsilon}} \\int_0^1\\left[ k_t^{\\alpha_1} \\ell_t^{\\alpha_2} \\cdot \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon \\alpha_1} \\cdot \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon\\alpha_2} \\right]^{\\frac{\\varepsilon-1}{\\varepsilon}} \\text{d} i \\\\ =\u0026 (Z_t k_t^{\\alpha_1} \\ell_t^{\\alpha_2})^{\\frac{\\varepsilon-1}{\\varepsilon}} \\cdot \\int_0^1 \\left(\\frac{P_t(i)}{P_t}\\right)^{1-\\varepsilon} \\text{d} i \\\\ % -------- y_t =\u0026 (Z_t k_t^{\\alpha_1} \\ell_t^{\\alpha_2}) \\cdot \\left[ \\int_0^1 \\left(\\frac{P_t(i)}{P_t}\\right)^{1-\\varepsilon} \\text{d} i \\right]^{\\frac{\\varepsilon}{\\varepsilon-1}} \\\\ =\u0026 (Z_t k_t^{\\alpha_1} \\ell_t^{\\alpha_2}) \\cdot \\left[ P_t^{\\varepsilon-1} \\cdot \\underbrace{ \\int_0^1 P_t(i)^{1-\\varepsilon} \\text{d} i }_{\\text{power to price index}} \\right]^{\\frac{\\varepsilon}{\\varepsilon-1}} \\\\ =\u0026 (Z_t k_t^{\\alpha_1} \\ell_t^{\\alpha_2}) \\cdot \\left[ P_t^{\\varepsilon-1} \\cdot P_t^{1-\\varepsilon} \\right]^{\\frac{\\varepsilon}{\\varepsilon-1}} \\\\ =\u0026 Z_t k_t^{\\alpha_1} \\ell_t^{\\alpha_2} \\end{aligned} $$Price dispersion is eliminated here because the intermediate producers use a constant returns to scale technology. In some standard applications, however, price dispersion appears explicitly in the aggregate output when production relies solely on labor \\(\\ell\\).\nProfit # The assumption of \\(Z_t(i)\\equiv Z_t\\) implies \\(M_t(i)\\equiv M_t\\) in our setup. The aggregate profit of the intermediate producers is\n$$ \\begin{aligned} \\Pi_t =\u0026 \\int_0^1 \\Pi_t(i) \\text{d} i = \\int_0^1 y_t(i) \\left( P_t(i) - M_t(i) \\right) \\text{d}i \\\\ % ------ =\u0026 y_t \\cdot \\int_0^1 \\left( P_t(i) - M_t(i) \\right) \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} \\text{d}i \\\\ % ------ =\u0026 y_t \\cdot \\left[ \\int_0^1 P_t(i) \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} \\text{d}i - \\int_0^1 M_t(i) \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} \\text{d}i \\right] \\\\ % ------ =\u0026 y_t \\cdot \\left[ P_t^{\\varepsilon} \\underbrace{\\int_0^1 P_t(i)^{1-\\varepsilon} \\text{d}i}_{\\text{power to price index}} - M_t \\underbrace{\\int_0^1 \\left(\\frac{P_t(i)}{P_t}\\right)^{-\\varepsilon} \\text{d}i }_{\\text{price dispersion}} \\right] \\\\ % ------ =\u0026 y_t \\cdot \\left[ P_t^{\\varepsilon} \\cdot P_t^{1-\\varepsilon} - M_t \\cdot \\delta_t \\right] \\\\ % ------ =\u0026 y_t \\cdot \\underbrace{(P_t - M_t \\delta_t)}_{\\text{premium}} \\end{aligned} $$One can instantly notice that the price dispersion directly changes the premium of unit goods (distributional effect).\n","date":"September 22, 2025","externalUrl":null,"permalink":"/posts/003_newkeynesianfirm/","section":"Blog","summary":"Derives the non-linear Phillips curve in NK models with Rotemberg price rigidity step by step. Helpful for students.","title":"Non-linear Phillips curve in NK model step-by-step","type":"posts"},{"content":" Consider a controlled Markovian process \\(Y=(X,Z)\\):\n$$ \\begin{aligned} \u0026 X' = f(X,Z) \\\\ \u0026 Z' \\sim \\text{MarkovianProcess}(Z) \\end{aligned} $$where \\(X \\in \\mathbb{R}^N\\) is a vector of endogenous states that evolves according to some rules \\(f\\); \\(Z \\in \\mathbb{R}^M\\) is an exogenous process that drives the stochasticity of the joint process \\(Y=(X,Z)\\). The structure accommodates many models on which a recursive equilibrium can be defined.\nYoung (2010)\u0026rsquo;s non-stochastic simulation algorithm provides a convenient tool to approximate such a controlled Markov process \\(Y\\) with a finite-state Markov chain. However, typical implementations of the algorithm focus on univariate case i.e. \\(X\\in\\mathbb{R}\\) which is common in Krusell-Smith model. My package MultivariateMarkovChains.jl implements the multivariate version of Young\u0026rsquo;s algorithm and provides a generic API. This post explains how the multivariate version algorithm works.\nTo kick off the algorithm, assume:\nThe process of \\(Z\\) is (or has been approximated by) a finite-state multivariate Markov chain \\((\\mathcal{Z},P_Z)\\) where \\(\\mathcal{Z}\\in\\{\\mathbb{R}^{M}\\}^{D_Z}\\) is the vector of total \\(D_Z\\) states, and \\(P_Z \\in\\mathbb{R}^{D_Z\\times D_Z}\\) is the transition matrix. The Markov chain is totally exogenous and is not affected by \\(X\\). The function \\(f(X,Z):\\mathbb{R}^{N}\\times \\mathbb{R}^{M} \\to \\mathbb{R}^{N}\\) is a continuous mapping that decides the transition from \\(X\\) to next period\u0026rsquo;s \\(X'\\). The economist has got a desired grid \\(\\mathcal{X}\\in\\mathbb{R}^{D_N}\\) for \\(X\\). The grid is typically obtained by Cartesian/tensor joining \\(X\\)\u0026rsquo;s every dimension\u0026rsquo;s grid. For example, let \\(\\mathcal{X}_i := [X_i^1,\\dots,X_i^{N_i}] \\in\\mathbb{R}^{N_i}\\) be a grid for the \\(i\\)-th dimension of \\(X\\), then $$ \\begin{aligned} \\mathcal{X} := \\otimes^N_{i=1} \\mathcal{X}_i \\in \\{\\mathbb{R}^{N}\\}^{\\prod_{i=1}^NN_i} \\end{aligned} $$The challenge of Young\u0026rsquo;s algorithm is to properly allocate the grid for \\((X,Z)\\): the dependency of \\(f\\) on \\(Z\\) makes it wrong to separately construct a chain for \\(X\\) and a chain \\(Z\\) then merge them together as if they are independent from each other. To properly handle this issue, we do the following procedures:\nStep 1: design the finite state space for \\(Y=(X,Z)\\) joint process. The space has \\(D_X \\cdot D_Z\\) states and every state is a \\(N+M\\) vector.\n$$ \\mathcal{Y} := \\mathcal{X} \\times \\mathcal{Z} $$Step 2: allocate the transition matrix \\(P_Y\\) of size \\((D_XD_Z,D_XD_Z)\\).\nStep 3: loop over all \\(Y\\) grid points in \\(\\mathcal{Y}\\). At each point \\(Y^i\\), do the following steps:\nGiven \\(Y^i\\), evaluate \\(f(X^i,Z^i)\\) to get the next period\u0026rsquo;s \\(X^{i'}\\) prediction which is continuous and likely to not match any grid point Construct a discrete distribution over \\(\\mathcal{X}\\) in which the probabilities is propotional to the distance between every grid point to the \\(X^{i'}\\) prediction. Let the distribution/density/probability vector be (p^i$ The distance typically only considers the first two nearest neighbor grid points but truncate the probabilities for all the left grid points to zero. This is for sparsity of the transition dynamics. It leads to \\(2\\) support grid points over \\(\\mathcal{X}\\) The distance is usually normalized along each dimension to avoid the scale effects. An alternative method is to use the two nearest neighbor grid points for every dimension, which leads to \\(2N\\) support grid points over \\(\\mathcal{X}\\) Construct the \\(i\\)-th row of the transition matrix \\(P_Y\\) by Kronecker/tensor product \\(P_{Z,i} \\otimes p^i\\) where \\(P_{Z,i}\\) is the row of \\(Z\\)\u0026rsquo;s transition matrix that corresponds to the \\(Z\\) components of \\(Y^i\\). Step 4: Construct a MultivariateMarkovChain instance by passing in the state space \\(\\mathcal{Y}\\) and the transition matrix \\(P_Y\\).\nSo far, we have successfully implemented the multivariate case of Young (2010)\u0026rsquo;s algorithm. In package MultivariateMarkovChains.jl, users can simply run:\nyoung( f, # function f(X,Z) that receives two vectors and returns X\u0026#39; prediction Zproc, # a `MultivariateMarkovChain` instance that defines Z\u0026#39;s (exogenous) dynamics xgrids, # an N-vector of grid (vector of grid points) for every dimension of X ) And everything is done automatically.\nNotes: if your controlled Markoc process has \\(X'=f(X)\\) i.e. the motion of \\(X\\) is independent from \\(Z\\), then merge() function should be good enough.\nYoung, Eric R. “Solving the Incomplete Markets Model with Aggregate Uncertainty Using the Krusell–Smith Algorithm and Non-Stochastic Simulations.” Journal of Economic Dynamics and Control 34, no. 1 (2010): 36–41. https://doi.org/10.1016/j.jedc.2008.11.010 . ","date":"August 2, 2025","externalUrl":null,"permalink":"/posts/002_multivariateyoung2010/","section":"Blog","summary":"Explains how to implement the multivariate case of Young (2010) non-stochastic simulation algorithm.","title":"Multivariate case for Young (2010) non-stochastic simulation","type":"posts"},{"content":"","date":"July 28, 2025","externalUrl":null,"permalink":"/tags/code/","section":"Tags","summary":"","title":"Code","type":"tags"},{"content":"This page displays my projects and code\n","date":"July 28, 2025","externalUrl":null,"permalink":"/code/","section":"Data and code","summary":"","title":"Data and code","type":"code"},{"content":"","date":"July 28, 2025","externalUrl":null,"permalink":"/tags/julia/","section":"Tags","summary":"","title":"Julia","type":"tags"},{"content":"Project link: github.com/Clpr/MultivariateMarkovChains.jl This package provides flexible API to define, approximate, manupulate, estimate and simulate multivariate (vector-valued) finite state Markov chains in discrete time. Some popular algorithms are also implemented such as Tauchen (1985) and Young (2010) non-stochastic simulation methods. It is super helpful in the parameterization of dynamic macroeconomic models as well as other generic numerical applications of stochastic analysis.\nTo learn more about the functionalities and usage, check the project on GitHub.\nThis package has not been registered at Julia\u0026rsquo;s general registry yet. To install it, run:\npkg\u0026gt; add \u0026#34;https://github.com/Clpr/MultivariateMarkovChains.jl.git\u0026#34; In the future, one may run:\npkg\u0026gt; add MultivariateMarkovChains ","date":"July 28, 2025","externalUrl":null,"permalink":"/code/multivariatemarkovchains.jl/","section":"Data and code","summary":"This package provides types and methods for modeling vector-valued Markov chains in discrete time. It is useful for dynamic macroeconomic models and generic stochastic analysis. Project link: github.com/Clpr/MultivariateMarkovChain.jl","title":"MultivariateMarkovChains.jl","type":"code"},{"content":"","date":"July 28, 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Blowfish​ is a highly flexible framework within the ​Hugo​ ecosystem, allowing users to quickly build visually appealing websites in just minutes. A typical Blowfish (and Hugo) website is structured around \u0026ldquo;posts\u0026rdquo; or \u0026ldquo;articles.\u0026rdquo; Each post may include a cover image, commonly referred to as a \u0026ldquo;thumbnail\u0026rdquo; as demonstrated on this website.\nAn example cover/thumbnail picture The default ways to specify the cover picture for a post:\nPutting a picture file with substring \u0026ldquo;feature\u0026rdquo; in the same folder as the index.md of the post Use featureimage: PICTURE_URL to cite an online picture While Blowfish (and Hugo) allows each post to specify its own cover image, this approach can lead to inefficiencies. Storing duplicate copies of the same image across multiple posts is unnecessary, especially when cover images are large. A more efficient approach would be to reuse a single image (or a set of images) stored in assets/ or another directory, rather than embedding duplicates in each post. However, this is not currently supported. Blowfish’s featureimage parameter only accepts remote URLs, not local assets. This post introduces a new parameter, featureAsset (or a name of your choice), which allows referencing a local asset image (e.g., featureAsset: \u0026quot;img/feature_default.png\u0026quot;) directly in a post’s TOML front matter. This enables efficient reuse of cover images while maintaining flexibility.\nThis post is based on the discussion thread by @f-hollow on GitHub.\nIdea: We have to tell the compiler when and where to find the asset picture in the process of website building. This requries to modify the theme partial templates according to which hero style you are applying to your website.\nFisrt, copy themes/blowfish/layouts/partials/article-link/ and themes/blowfish/layouts/partials/hero/ to layouts/partials/ folder. The files stored in layouts/partials/ would overwrite the default Blowfish building files in the compilation process.\nExplain: the building files in article-link/ controls how the gallery files (named as _index.md) are parsed and compiled Explain: the building files in hero/ controls how the generic page/post/article files (named as index.md) are parsed and compiled Then, let\u0026rsquo;s check the building files in layouts/partials/article-link/. In the Blowfish version of writing this post (2.88.1), there should be 3 files:\nsimple.html: for showCards=false in the [list] section of the TOML file config/_default/params.toml. This building file works for the case where the posts are listed as top-to-bottom lists. card.html and card-related.html: for showCards=true. These builidng files works for the case where the posts are organized as cards. WLOG, let\u0026rsquo;s check simple.html. Reading this building file, one can quickly locate the related shortcodes that check and set up the cover pictures. e.g.\n1{{- with $.Params.images -}} 2{{- range first 6 . }} 3\u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . | absURL }}\u0026#34; /\u0026gt;{{ end -}} 4{{- else -}} 5{{- $images := $.Resources.ByType \u0026#34;image\u0026#34; -}} 6{{- $featured := $images.GetMatch \u0026#34;*feature*\u0026#34; -}} 7 8{{- if not $featured }}{{ $featured = $images.GetMatch \u0026#34;{*cover*,*thumbnail*}\u0026#34; }}{{ end -}} 9{{ if and .Params.featureimage (not $featured) }} 10{{- $url:= .Params.featureimage -}} 11{{ $featured = resources.GetRemote $url }} 12{{ end }} 13{{- if not $featured }}{{ with .Site.Params.defaultFeaturedImage }}{{ $featured = resources.Get . }}{{ end }}{{ end -}} 14{{ if .Params.hideFeatureImage }}{{ $featured = false }}{{ end }} 15{{- with $featured -}} 16{{ if or $disableImageOptimization (strings.HasSuffix $featured \u0026#34;.svg\u0026#34;)}} 17 {{ with . }} 18 \u0026lt;div class=\u0026#34;{{ $articleImageClasses }}\u0026#34; style=\u0026#34;background-image:url({{ .RelPermalink }});\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 19 {{ end }} 20 {{ else }} 21 {{ with .Resize \u0026#34;600x\u0026#34; }} 22 \u0026lt;div class=\u0026#34;{{ $articleImageClasses }}\u0026#34; style=\u0026#34;background-image:url({{ .RelPermalink }});\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 23 {{ end }} 24 {{ end }} 25{{- else -}} 26{{- with $.Site.Params.images }} 27\u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ index . 0 | absURL }}\u0026#34; /\u0026gt;{{ end -}} 28{{- end -}} 29{{- end -}} This shortcode block basiclly: first search if there exists a file with substring feature, cover, thumbnail in the same folder; if not, then check if featureimage parameter is set in the TOML front matter; if not, then use default feature picture (set in config/_default/params.toml); if no default picture, then hide the cover picture.\nThen, we need to modify this block by inserting the following condition codes between line 6 and 8 (to prioritize our specification):\n1{{ if and .Params.featureAsset (not $featured) }} 2 {{- $genericImage:= .Params.featureAsset -}} 3 {{ $featured = resources.Get $genericImage }} 4{{ end }} This shortcode block basically does: check if there is a parameter featureAsset in the TOML front matter; if yes and the featured value has not been successfully set yet, then set it using the provided path (resources.Get RELATIVE_PATH refers to the assets/ folder which should be the root folder of the relative path).\nAfter understanding the idea, one can modify all the other building files in the same way. Then, a Markdown post file (not the gallery file) can have a TOML front matter like:\n--- title: \u0026#34;Blowfish: One cover picture for all posts\u0026#34; date: 2025-07-16T00:00:01-07:00 showAuthor: true showAuthorsBadges : true showSummary: true summary: \u0026#34;Shows how to specify cover/thumbnail picture for each post using assets without duplicate copies.\u0026#34; featureAsset: \u0026#34;img/feature_default.webp\u0026#34; --- ","date":"July 16, 2025","externalUrl":null,"permalink":"/posts/001_customthumbnailpicture/","section":"Blog","summary":"Shows how to specify cover/thumbnail picture for each post using assets without duplicate copies.","title":"Blowfish: One cover picture for all posts","type":"posts"},{"content":"Project link: github.com/Clpr/AdaptiveSG.jl This package provides object-oriented API to define, train, evaluate and adapt multi-linear Adaptive Sparse Grid (ASG) interpolations. It can be used to solve high-dimensional discrete/continuous time models; perform high-dimensional non-parametric estimations; and help with other high-dimensional numerical exercises.\nThis package has been registered at Julia\u0026rsquo;s general registry. To install it, simply run:\npkg\u0026gt; add AdaptiveSG.jl ","date":"May 1, 2025","externalUrl":null,"permalink":"/code/adaptivesg.jl/","section":"Data and code","summary":"This package provides object-oriented API to define, train, evaluate and adapt multi-linear Adaptive Sparse Grid (ASG) interpolations. Project link: github.com/Clpr/AdaptiveSG.jl","title":"AdaptiveSG.jl","type":"code"},{"content":"Seesion: Introduction to continuous time macroeconomics\nSlides ","date":"April 30, 2025","externalUrl":null,"permalink":"/teach/2025_beihang_macro2/","section":"Teaching","summary":"Spring 2025, Beihang University. Seesion: Introduction to continuous time macroeconomics","title":"Advanced Macroeconomics (Session 1)","type":"teach"},{"content":" Teaching assistantship # ECON 421: Microeconometric Data Analytics, Spring 2024 (Spring 2024) ECON 610: Macroeconomic Theory (Fall 2023) ECON 212: Intermediate Macroeconomics (Fall 2023) ECON 363: Political Economy of China (Spring 2023, Fall 2021, Fall 2020) ECON 112: Principle of Macroeconomics (Spring 2022) ","date":"April 30, 2025","externalUrl":null,"permalink":"/teach/","section":"Teaching","summary":"","title":"Teaching","type":"teach"},{"content":" Project URL: https://github.com/Clpr/BoxDomains.jl BoxDomains.jl provides convenient abstractions of mutli-dimensional bounded space like\n$$ \\mathcal{X} := \\prod_{j=1}^D [\\underline{x}_j, \\bar{x}_j] $$which are everywhere in economic modeling. The package allows users to define, manipulate, slice, transform, and discretize such spaces. The data structures are lazy. In particular, most of the operations overload Julia Base such that users can have a native coding experience.\nThis package has been registered at Julia\u0026rsquo;s general registry. To install it, simply run:\npkg\u0026gt; add BoxDomains.jl ","date":"April 30, 2025","externalUrl":null,"permalink":"/code/boxdomains.jl/","section":"Data and code","summary":"A Julia implementation of box domains like [a1,b1]*[a2,b2]\u0026hellip;. which are everywhere in economic modeling. The package allows users to define, manipulate, slice, transform, and discretize such spaces. In particular, most of the operations overload Julia Base such that users can have a native coding experience. Project URL: \u003ccode\u003ehttps://github.com/Clpr/BoxDomains.jl\u003c/code\u003e","title":"BoxDomains.jl","type":"code"},{"content":"Project URL: https://github.com/Clpr/ConstrainedSimplexSearch.jl This repository implements the Constrained Nelder-Mead (simplex) Search algorithm which is generalized from the unconstrained Nelder-Mead search method. It handles generic non-linear equality and inequality constraints using penalty which guides the simplex to move towards the admissible space. This package provides a robust solver for high-dimensional quantitative macroeconomic models where: 1. endogeneous constraints are imposed; 2. boundary bindingness are important; 3. High-dimensional numerical approximations are oscilliating.\nThis package has been registered at Julia\u0026rsquo;s general registry. To install it, simply run:\npkg\u0026gt; add ConstrainedSimplexSearch.jl ","date":"April 29, 2025","externalUrl":null,"permalink":"/code/constrainedsimplexsearch.jl/","section":"Data and code","summary":"This repository implements the Constrained Nelder-Mead (simplex) Search algorithm. It handles generic non-linear equality and inequality constraints using penalty which guides the simplex to move towards the admissible space. Project URL: \u003ccode\u003ehttps://github.com/Clpr/ConstrainedSimplexSearch.jl\u003c/code\u003e","title":"ConstrainedSimplexSearch.jl","type":"code"},{"content":"Project URL: https://github.com/Clpr/CountyPlus CountyPlus is an open-source panel dataset that covers 3000+ U.S. counties from 2003 to 2019. It consists of 100+ variables, including demographic, geographic, household balance sheet, local economy indicators. Specially, this dataset estimates household consumption, measure of local financial friction, and measure of local nominal friction (Downward Nominal Wage Rigidity).\n(Version 0.0.2 is available now! Newly added 04-19 identified net worth shock and spatial weight matrices)\n","date":"April 15, 2025","externalUrl":null,"permalink":"/code/countyplus/","section":"Data and code","summary":"CountyPlus is an open-source panel dataset that covers 3000+ U.S. counties from 2003 to 2019.This dataset estimates household consumption, measure of local financial friction, and measure of local nominal friction (Downward Nominal Wage Rigidity). Project URL: \u003ccode\u003ehttps://github.com/Clpr/CountyPlus\u003c/code\u003e","title":"CountyPlus","type":"code"},{"content":"","date":"April 15, 2025","externalUrl":null,"permalink":"/tags/data/","section":"Tags","summary":"","title":"Data","type":"tags"},{"content":"","date":"April 15, 2025","externalUrl":null,"permalink":"/tags/stata/","section":"Tags","summary":"","title":"Stata","type":"tags"},{"content":"Syllabus: PDF ","date":"December 5, 2022","externalUrl":null,"permalink":"/teach/2022_emory_econ112/","section":"Teaching","summary":"Fall 2022, Emory University","title":"ECON 112: Principles of Macroeconomics","type":"teach"},{"content":" content/about.md # Hi there!\n","externalUrl":null,"permalink":"/about/","section":"homepage","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"This page displays my research projects.\nWorking paper # Frictions, net worth shocks, and heterogenous impacts (with Cheng Ding; under review at American Economic Journal: Macroeconomics) Work in progress # Financial dollarization, exchange rate, and macroprudential policy (with Cheng Ding, Vivian Yue, and Aliaksandr Zaretski) Saving rate and entrepreneurship in post-2010 China (with Kaiji Chen and Kai Zhao) Journal articles # Population aging and its effects on the gap of Urban Public Health Insurance in China . (2021) China Economic Review. with Yunyun Jiang and Haitao Zheng Socioeconomic status and morbidity rate inequality in China: Based on NHSS and CHARLS data . (2019) IJERPH. with Yunyun Jiang and Haitao Zheng Conference \u0026amp; seminar # 2025 Chinese Economists Society 2025 North America Annual Conference, University of Michigan 2024 Brownbag seminar, Nov 20, Federal Reserve Bank of Atlanta 30th Anniversary of the Midwest Macroeconomics Meetings, Purdue University International Conference on Empirical Economics, session chair, Pennsylvania State University at Altoona (virtual) Other research # Human Stone Toolmaking Action Grammar (HSTAG): A Challenging Benchmark for Fine-grained Motor Behavior Recognition . (2024) IEEE DSAA. with Cheng Liu et al. ","externalUrl":null,"permalink":"/research/","section":"homepage","summary":"","title":"Research","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]